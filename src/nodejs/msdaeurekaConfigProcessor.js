/*
  Copyright (c) 2017, F5 Networks, Inc.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  *
  http://www.apache.org/licenses/LICENSE-2.0
  *
  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
  either express or implied. See the License for the specific
  language governing permissions and limitations under the License.
  
  Updated by Ping Xiong on May/15/2022.
  Updated by Ping Xiong on Jun/30/2022, using global var for polling signal.
*/

'use strict';

// Middleware. May not be installed.
var configTaskUtil = require("./configTaskUtil");
var blockUtil = require("./blockUtils");
var logger = require('f5-logger').getInstance();
var mytmsh = require('./TmshUtil');
const fetch = require('node-fetch');
const Bluebird = require('bluebird');
fetch.Promise = Bluebird;

// Setup a polling signal for audit.
//var fs = require('fs');
//const msdaeurekaOnPollingSignal = '/var/tmp/msdaeurekaOnPolling';
global.msdaeurekaOnPolling = [];


//const pollInterval = 10000; // Interval for polling Registry registry.
//var stopPolling = false;

// For functionnal verification
//const poolName = 'pool_msda_demo';
//const poolType = 'round-robin';
//const healthMonitor = 'tcp';
var poolMembers = '{100.100.100.100:8080 100.100.100.101:8080}';
//const commandCreatePool ='tmsh -a create ltm pool pool_msda_demo monitor tcp load-balancing-mode round-robin members replace-all-with { 100.100.100.100:8080 100.100.100.101:8080 }';
//const commandUpdatePool ='tmsh -a modify ltm pool pool_msda_demo monitor tcp load-balancing-mode round-robin members replace-all-with { 100.100.100.100:8080 100.100.100.101:8080 }';
//const commandDeletePool ='tmsh -a delete ltm pool pool_msda_demo';

// tmsh -a create ltm pool /Common/pool_msda_demo
// tmsh -a modify ltm pool /Common/pool_msda_demo monitor tcp load-balancing-mode round-robin members replace-all-with { 100.100.100.100:8080 100.100.100.101:8080 }

/**
 * A dynamic config processor for managing LTM pools.
 * Note that the pool member name is not visible in the GUI. It is generated by MCP according to a pattern, we don't want
 * the user setting it
 *
 * @constructor
 */
function msdaeurekaConfigProcessor() {
}

msdaeurekaConfigProcessor.prototype.setModuleDependencies = function (options) {
    logger.info("setModuleDependencies called");
    configTaskUtil = options.configTaskUtil;
};

msdaeurekaConfigProcessor.prototype.WORKER_URI_PATH = "shared/iapp/processors/msdaeurekaConfig";

msdaeurekaConfigProcessor.prototype.onStart = function (success) {
    logger.fine("MSDA: OnStart, msdaeurekaConfigProcessor.prototype.onStart");
    this.apiStatus = this.API_STATUS.INTERNAL_ONLY;
    this.isPublic = true;

    configTaskUtil.initialize({
        restOperationFactory: this.restOperationFactory,
        eventChannel: this.eventChannel,
        restHelper: this.restHelper
    });
 
    success();
};


/**
 * Handles initial configuration or changed configuration. Sets the block to 'BOUND' on success
 * or 'ERROR' on failure. The routine is resilient in that it will try its best and always go
 * for the 'replace' all attitude.
 *
 * @param restOperation - originating rest operation that triggered this processor
 */
msdaeurekaConfigProcessor.prototype.onPost = function (restOperation) {
    var configTaskState,
        blockState,
        oThis = this;
    logger.fine("MSDA: onPost, msdaeurekaConfigProcessor.prototype.onPost");

    var inputProperties;
    var dataProperties;
    try {
        configTaskState = configTaskUtil.getAndValidateConfigTaskState(restOperation);
        blockState = configTaskState.block;
        logger.fine("MSDA: onPost, inputProperties ", blockState.inputProperties);
        logger.fine("MSDA: onPost, dataProperties ", blockState.dataProperties);
        inputProperties = blockUtil.getMapFromPropertiesAndValidate(
            blockState.inputProperties,
            ["eurekaEndpoint", "servicePath", "serviceName", "poolName", "poolType", "healthMonitor"]
        );
        dataProperties = blockUtil.getMapFromPropertiesAndValidate(
            blockState.dataProperties,
            ["pollInterval"]
        );

    } catch (ex) {
        restOperation.fail(ex);
        return;
    }

    // Mark that the request meets all validity checks and tell the originator it was accepted.
    this.completeRequest(restOperation, this.wellKnownPorts.STATUS_ACCEPTED);

    // Generic URI components, minus the 'path'
    var uri = this.restHelper.buildUri({
        protocol: this.wellKnownPorts.DEFAULT_HTTP_SCHEME,
        port: this.wellKnownPorts.DEFAULT_JAVA_SERVER_PORT,
        hostname : "localhost"
    });

    //Accept input proterties, set the status to BOUND.

    const inputEndPoint = inputProperties.eurekaEndpoint.value;
    const inputServicePath = inputProperties.servicePath.value;
    const inputServiceName = inputProperties.serviceName.value;
    const inputPoolName = inputProperties.poolName.value;
    const inputPoolType = inputProperties.poolType.value;
    const inputMonitor = inputProperties.healthMonitor.value;
    var pollInterval = dataProperties.pollInterval.value * 1000;

    // Check the existence of the pool in BIG-IP, create an empty pool if the pool doesn't exist.
    mytmsh.executeCommand("tmsh -a list ltm pool " + inputPoolName)
    .then(function () {
        logger.fine("MSDA: onPost, found the pool, no need to create an empty pool.");
        return;
    }, function (error) {
        logger.fine("MSDA: onPost, GET of pool failed, adding an empty pool: " + inputPoolName);
        let inputEmptyPoolConfig = inputPoolName + ' monitor ' + inputMonitor + ' load-balancing-mode ' + inputPoolType + ' members none';
        let commandCreatePool = 'tmsh -a create ltm pool ' + inputEmptyPoolConfig;
        return mytmsh.executeCommand(commandCreatePool);
    })
    .catch(function (error) {
        logger.fine("MSDA: onPost, list pool failed: " + error.message);
    });


    // Set the polling interval
    if (pollInterval) {
        if (pollInterval < 10000) {
            logger.fine("MSDA: onPost, pollInternal is too short, will set it to 10s ", pollInterval);
            pollInterval = 10000;
        }
    } else {
        logger.fine("MSDA: onPost, pollInternal is not set, will set it to 30s ", pollInterval);
        pollInterval = 30000;
    }
    
    // Setup the polling signal for audit
    if (global.msdaeurekaOnPolling.includes(inputPoolName)) {
        return logger.fine("MSDA: onPost, already has an instance polling the same pool, please check it out: " + inputPoolName);
    } else { 
        global.msdaeurekaOnPolling.push(inputPoolName);
        logger.fine("MSDA onPost: set msdaeurekaOnpolling signal: ", global.msdaeurekaOnPolling);
    }

    logger.fine("MSDA: onPost, Input properties accepted, change to BOUND status, start to poll Registry for: " + inputPoolName);

    //stopPolling = false;

    configTaskUtil.sendPatchToBoundState(configTaskState, 
            oThis.getUri().href, restOperation.getBasicAuthorization());

    // A internal service to retrieve service member information from registry, and then update BIG-IP setting.

    //inputEndPoint = inputEndPoint.toString().split(","); 
    logger.fine("MSDA: onPost, registry endpoints: " + inputEndPoint);

    // connect to eureka registry to retrieve end points.
    const absoluteUrl = inputEndPoint + inputServicePath + inputServiceName;

    (function schedule() {
        var pollRegistry = setTimeout(function () {
            fetch(absoluteUrl, { headers: {'Accept': 'application/json'} })
                .then(res => res.json())
                .then(function(jsondata) {
                    let nodeAddress = [];
                    if (jsondata.message === 'Not Found') {
                        console.log("MSDA: onPost, Service not found: ");
                    } else {
                        let instanceList = jsondata.application.instance;
                        if (instanceList instanceof Array) {
                            instanceList.forEach(element => {
                                //console.log("instance: ", element);
                                //console.log("port: ", element.port)
                                nodeAddress.push(element.ipAddr + ":" + element.port.$);
                            }) 
                        } else {
                            nodeAddress.push(instanceList.ipAddr+ ":"+instanceList.port.$);
                        }
                    }
                    logger.fine("MSDA: onPost, service endpoint list: ", nodeAddress);
                    if (nodeAddress.length !== 0) {
                        
                        logger.fine("MSDA: onPost, Will moving forward to setup BIG-IP");

                        //To configure the BIG-IP pool
                        poolMembers = "{" + nodeAddress.join(" ") + "}";
                        logger.fine("MSDA: onPost, pool members: " + poolMembers);
                        let inputPoolConfig = inputPoolName + ' monitor ' + inputMonitor + ' load-balancing-mode ' + inputPoolType + ' members replace-all-with ' + poolMembers;

                        // Use tmsh to update BIG-IP configuration instead of restful API

                        // Start with check the exisitence of the given pool
                        mytmsh.executeCommand("tmsh -a list ltm pool " + inputPoolName).then(function () {
                            logger.fine("MSDA: onPost, Found a pre-existing pool. Update pool setting: " + inputPoolName);
                            let commandUpdatePool = 'tmsh -a modify ltm pool ' + inputPoolConfig;
                            return mytmsh.executeCommand(commandUpdatePool);
                        }, function (error) {
                            logger.fine("MSDA: onPost, GET of pool failed, adding from scratch: " + inputPoolName);
                            let commandCreatePool = 'tmsh -a create ltm pool ' + inputPoolConfig;
                            return mytmsh.executeCommand(commandCreatePool);
                        })
                            // Error handling
                            .catch(function (error) {
                                logger.fine("MSDA: onPost, Add Failure: adding/modifying a pool: " + error.message);
                            });

                    } else {
                        //To clear the pool
                        logger.fine("MSDA: onPost, endpoint list is empty, will clear the BIG-IP pool as well");
                        mytmsh.executeCommand("tmsh -a list ltm pool " + inputPoolName)
                            .then(function () {
                                logger.fine("MSDA: onPost, found the pool, will delete all members as it's empty.");
                                let commandUpdatePool = 'tmsh -a modify ltm pool ' + inputPoolName + ' members delete { all}';
                                return mytmsh.executeCommand(commandUpdatePool)
                                    .then(function (response) {
                                        logger.fine("MSDA: onPost, update the pool to delete all members as it's empty. ");
                                    });
                            }, function (error) {
                                logger.fine("MSDA: onPost, GET of pool failed, adding an empty pool: " + inputPoolName);
                                let inputEmptyPoolConfig = inputPoolName + ' monitor ' + inputMonitor + ' load-balancing-mode ' + inputPoolType + ' members none';
                                let commandCreatePool = 'tmsh -a create ltm pool ' + inputEmptyPoolConfig;
                                return mytmsh.executeCommand(commandCreatePool);
                            })
                                // Error handling - Set the block as 'ERROR'
                            .catch(function (error) {
                                logger.fine("MSDA: onPost, Delete failed: " + error.message);
                            });
                    }
                }, function (err) {
                    logger.fine("MSDA: onPost, Fail to retrieve to endpoint list due to: ", err.message);
                }).catch(function (error) {
                    logger.fine("MSDA: onPost, Fail to retrieve to endpoint list due to: ", error.message);
                });
            schedule();
        }, pollInterval);

        // Stop polling while undeployment
        if (global.msdaeurekaOnPolling.includes(inputPoolName)) {
            logger.fine("MSDA: onPost, keep polling registry  for: " + inputPoolName);            
        } else {
            process.nextTick(() => {
                clearTimeout(pollRegistry);
                logger.fine("MSDA: onPost/stopping, Stop polling registry  for: " + inputPoolName);
            });
            // Delete pool configuration in case it still there.
            setTimeout (function () {
                const commandDeletePool = 'tmsh -a delete ltm pool ' + inputPoolName;
                mytmsh.executeCommand(commandDeletePool)
                .then (function () {
                    logger.fine("MSDA: onPost/stopping, the pool removed: " + inputPoolName);
                })
                    // Error handling
                .catch(function (err) {
                    logger.fine("MSDA: onPost/stopping, Delete failed: " + inputPoolName + err.message);
                });
            }, 2000);
        }
    })();
};


/**
 * Handles DELETE. The configuration must be removed, if it exists. Patch the block to 'UNBOUND' or 'ERROR'
 *
 * @param restOperation - originating rest operation that triggered this processor
 */
msdaeurekaConfigProcessor.prototype.onDelete = function (restOperation) {
    var configTaskState,
        blockState;
    var oThis = this;

    logger.fine("MSDA: onDelete, msdaeurekaConfigProcessor.prototype.onDelete");

    var inputProperties;
    try {
        configTaskState = configTaskUtil.getAndValidateConfigTaskState(restOperation);
        blockState = configTaskState.block;
        inputProperties = blockUtil.getMapFromPropertiesAndValidate(blockState.inputProperties,
            ["poolName", "poolType"]);
    } catch (ex) {
        restOperation.fail(ex);
        return;
    }
    this.completeRequest(restOperation, this.wellKnownPorts.STATUS_ACCEPTED);

    // Generic URI components, minus the 'path'
    var uri = this.restHelper.buildUri({
        protocol: this.wellKnownPorts.DEFAULT_HTTP_SCHEME,
        port: this.wellKnownPorts.DEFAULT_JAVA_SERVER_PORT,
        hostname: "localhost"
    });

    // In case user requested configuration to deployed to remote
    // device, setup remote hostname, HTTPS port and device group name
    // to be used for identified requests

    // Use tmsh to update configuration

    mytmsh.executeCommand("tmsh -a list ltm pool " + inputProperties.poolName.value)
        .then(function () {
            logger.fine("MSDA: onDelete, delete Found a pre-existing pool. Full Config Delete: " + inputProperties.poolName.value);
            const commandDeletePool = 'tmsh -a delete ltm pool ' + inputProperties.poolName.value;
            return mytmsh.executeCommand(commandDeletePool)
                .then (function (response) {
                    logger.fine("MSDA: onDelete, the pool removed: " + inputProperties.poolName.value);
                    configTaskUtil.sendPatchToUnBoundState(configTaskState,
                        oThis.getUri().href, restOperation.getBasicAuthorization());
                    });
        }, function (error) {
            // the configuration must be clean. Nothing to delete
            logger.fine("MSDA: onDelete, pool does't exist: " + error.message);
            configTaskUtil.sendPatchToUnBoundState(configTaskState, 
                oThis.getUri().href, restOperation.getBasicAuthorization());
        })
        // Error handling - Set the block as 'ERROR'
        .catch(function (error) {
            logger.fine("MSDA: onDelete, Delete failed, setting block to ERROR: " + error.message);
            configTaskUtil.sendPatchToErrorState(configTaskState, error,
                oThis.getUri().href, restOperation.getBasicAuthorization());
        })
        // Always called, no matter the disposition. Also handles re-throwing internal exceptions.
        .done(function () {
            logger.fine("MSDA: onDelete, delete DONE!!! Continue to clear the polling signal for: : " + inputProperties.poolName.value);  // happens regardless of errors or no errors ....
            // Delete the polling signal
            let signalIndex = global.msdaeurekaOnPolling.indexOf(inputProperties.poolName.value);
            global.msdaeurekaOnPolling.splice(signalIndex,1);
        });
    
    /*
    // Stop polling registry while undeploy ??
    process.nextTick(() => {
        stopPolling = true;
        logger.fine("MSDA: onDelete/stopping, Stop polling registry ...");
    });
    //stopPollingEvent.emit('stopPollingRegistry');
    */
    logger.fine("MSDA: onDelete, Stop polling Registry while ondelete action.");
};

module.exports = msdaeurekaConfigProcessor;
